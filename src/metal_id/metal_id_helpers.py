from pathlib import Path
import argparse
import subprocess
import logging
from iotbx import pdb


def ensure_unique_directory(path):
    path = Path(path)
    counter = 1
    new_path = path

    while new_path.exists():
        new_path = path.with_name(f"{path.stem}_{counter}{path.suffix}")
        counter += 1

    return new_path


def file_or_code(value):
    if Path(value).is_file():
        return Path(value)
    elif len(value) == 4 and value.isalnum():
        return value
    else:
        raise argparse.ArgumentTypeError(
            f"Invalid pdb input: '{value}', must be valid four-character pdb code or an existing file path."
        )


def mtz_exists(input_file):
    if not Path(input_file).is_file():
        raise argparse.ArgumentTypeError(f"File not found: '{input_file}'.")
    return Path(input_file)


# Class for handling PDB as a file path or a four character code.
class PDBFileOrCode:
    def __init__(self, file_or_code):
        if Path(file_or_code).is_file():
            self.value = Path(file_or_code).resolve()
            self.is_file = True
        elif len(file_or_code) == 4 and file_or_code.isalnum():
            self.value = str(file_or_code)
            self.is_file = False
        else:
            raise ValueError(
                f"Invalid input '{file_or_code}'. pdb must be given as a valid file or 4-character pdb code"
            )


def run_dimple(mtz, pdb, dimple_dir):
    if isinstance(pdb, list):
        pdb = " ".join(pdb)
    dimple_command = f"dimple {mtz} {pdb} {dimple_dir} --anode -fpng"

    logging.info(f"Running dimple with command:\n\n{dimple_command}\n")
    dimple_output = subprocess.run(
        dimple_command,
        shell=True,
        stdout=subprocess.PIPE,
        stderr=subprocess.STDOUT,
        text=True,
    )

    return dimple_output


def generate_coot_viewer_script(
    pdb_file: Path, diff_map: Path, rmsd_threshold: float
) -> Path:
    viewer_script = [
        "#!/usr/bin/env coot",
        "# python script for coot - generated by metal_ID",
        "import os",
        "import sys",
        "script_path = os.path.dirname(sys.argv[-1])",
        "set_nomenclature_errors_on_read('ignore')",
        f"i_pdb = read_pdb(os.path.join(script_path,'{pdb_file.name}'))",
        # Command usage: read_ccp4_map(path, is_diff_map)
        f"i_map = read_ccp4_map(os.path.join(script_path,'{diff_map.name}'), 1)",
        f"set_contour_level_in_sigma(i_map, {rmsd_threshold})",
        # Command usage: difference_map_peaks(map_ref, coords_ref, rmsd_iso_level, max_closeness, show_pos_peaks, show_neg_peaks, around_model_only)
        f"difference_map_peaks(i_map, i_pdb, {rmsd_threshold}, 0.0, 1, 0, 0)",
    ]
    viewer_script_path = diff_map.parent / "coot_view.py"

    with open(viewer_script_path, "w") as script_file:
        for line in viewer_script:
            script_file.write(line + "\n")

    return viewer_script_path


def are_pdbs_similar(file_1, file_2):
    """
    Determine if two pdb files have the same crystal symmetry, the same number
    and type of atoms and sufficiently similar unit cell and atomic coordinates
    within the defined tolerances
    """

    def read_pdb(file):
        """
        Read a pdb file to get crystal symmetry, atom names and atom coordinates
        """
        pdb_obj = pdb.input(file)
        sym = pdb_obj.crystal_symmetry()
        atoms = pdb_obj.atoms()
        atom_names = atoms.extract_name()
        list_atoms = list(atom_names)
        atom_coords = atoms.extract_xyz()
        list_coords = list(atom_coords)
        return sym, list_atoms, list_coords

    # Read pdb files
    sym_1, atoms_1, coords_1 = read_pdb(str(file_1))
    sym_2, atoms_2, coords_2 = read_pdb(str(file_2))

    # Use default if none set tolerances
    tolerances = {
        "rel_cell_length": 0.01,
        "abs_cell_angle": 1.0,
        "abs_coord_diff": 5.0,  # Units Å
    }

    # Compare symmetry
    is_similar_sym = sym_1.is_similar_symmetry(
        sym_2,
        relative_length_tolerance=tolerances["rel_cell_length"],
        absolute_angle_tolerance=tolerances["abs_cell_angle"],
    )
    if not is_similar_sym:
        logging.error("PDB file symmetries are too different")
        return False

    # Compare atom type/number
    if atoms_1 != atoms_2:
        logging.error("Different number or type of atoms in pdb files")

    # Compare atom coordinates
    combined_coords = zip(coords_1, coords_2)
    for xyz_1, xyz_2 in combined_coords:
        # Calculate the distance between xyz_1 and xyz_2
        diff = abs(
            (
                (xyz_1[0] - xyz_2[0]) ** 2
                + (xyz_1[1] - xyz_2[1]) ** 2
                + (xyz_1[2] - xyz_2[2]) ** 2
            )
            ** 0.5
        )
        if diff > tolerances["abs_coord_diff"]:
            logging.error(
                f"PDB atom coordinates have difference > tolerance ({tolerances['abs_coord_diff']} Å"
            )
            return False
    return True
